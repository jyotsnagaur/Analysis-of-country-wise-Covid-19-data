---
title: "FinalAssignment"
author: "JYOTSNA"
date: "2022-10-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Part A - Data Science Questions (12 marks)


<b>Q1. From your understanding of ethical data science, mention three principles of a code of ethics that any data scientist should consider.</b>

P1:As a data scientist, we should firstly produce truthful results to the public/stakeholders. We must abstain from producing false projections or 'truthful falsehood'.Truthful falsehood is projecting data in a misleading manner which shows a misleading trend to the people.

P2:It is important to respect the privacy of the people/stakeholders and seek their consent before collecting or using their data for any kind of analysis.

P3:It is important to remember that we remain a member of the society and it is important to work in a manner that is progressive for the society at large. As a data scientist we must be careful to not publish sensitive data and have no intentions of causing harm to public health and safety.




<b>Q2.To build a visualisation using the ggplot2 library, we use the following template:</b>

ggplot(data= [dataset], mapping = aes(x = [x-variable], y = [y-variable]))+
geom_xxx() +
other options 
Based on the above template, mention the main components of building a graph using ggplot2 and describe the meaning of each of these components.


There are 3 main components here:

a) the dataset which needs to be displayed. It has to be contained in a data frame/tibble and has to include the x-variable which comes on the x-axis and which is the independent/explanatory variable. It has to also include the y-variable which is the dependent/response variable which changes as x changes and is plotted on the y-axis

b) aesthetics, introduced by the function aes() that takes care of positioning/mapping the variables on the plot.It also includes other elements like color where we can specify if the plot needs to be colored as per a specific group or a specific color. It can include specification for alpha which shows the transparency of plot. It can also contain specification for linetype, size,shape,etc.

c) geometry, introduced by the function geom() that takes care of drawing the graph (bar graph, line, scatter plot, etc). There can be different geometries like horizontal,vertical,diagonal lines, barplot,contour,density plots,point,boxplot,jitter,polygon etc.All of these geometries can be plotted using their respective codes starting with geom_.




<b>Q3.Describe three properties of the correlation coefficient of two variables</b>


1.  The Magnitude of the correlation coefficient(R) represents the strength of the relationship. It ranges between -1 and +1.

2.  Direction of the relationship: This is indicated by the sign of the correlation coefficient. A positive R represents an increasing trend in the graph where the y-variable increases with increase in x-variable. A negative R represents a decreasing trend where y-variable decreases with increase in x-variable.

3.  The correlation coefficient is unit-less. The value will stay very similar even with scaling or normalising any of the variables. The correlation coefficient between x and y is same as the correlation coefficient between y and x. 




<b>Q4.Imagine we have a dataset that lists the heights of the fathers and their sons. You have built a linear model that encodes the relationship between the fathers’ heights and the sons’ heights as follows:</b>

lm(son ~ father, data = heights_data)

Call:
lm(formula = son ~ father, data = heights_data)

Coefficients:
(Intercept)    father  
70.45       0.50  
The estimated coefficient (i.e. intercept and slope), which describes the relationship between the fathers’ and sons’ heights can be interpreted as:


a) The intercept is the minimum or maximum value that can be achieved when the explanatory variable equals 0. Here the explanatory variable is the father's height and the response variable is the son's height. The intercept 70.45 units here can be interpreted as the constant difference that the father's and son's height will have, apart from their linear relationship. At any given father's height, the son's height is bound to be atleast 70.45 units more than the height of the father. In simple words, all sons in the dataset are taller than their father.

b) The slope quantifies the effect of explanatory variable(father's height) on the response variable(son's height). Here the slope measures: for each unit increase in the father's height, how much would the height of the son would increase. Here since the slope is 0.5, it means that for each 2 units increase in the height of the father, the height of the son increases by 1 unit.


# --------------------------------------------------------------------------------- #

# Part B: Data Preparation, exploring and modelling (78 marks)

Introduction:




Assumptions:





Data Description:
The four CSV files are described in the following table:
-Covid19.csv: Master file which includes information on continents,countries, and the daily new cases and the daily new deaths in each country
-Tests.csv:information about daily covid19 tests in each country
-Countries.csv:information about the countries
-Recovered.csv:information about the daily recovered cases in each country

## Task 1: Data Preparation and Wrangling: (21 marks)

### 1.Load and read the data from the CSV files and store them into dataframes named appropriately.


```{r}
library(tidyverse)


master_data <- read_csv("C:/joy_R/IDS_Finalexam/data/Covid19.csv")
head(master_data)
tests_info <- read_csv("C:/joy_R/IDS_Finalexam/data/Tests.csv")
head(tests_info)
country_info <- read_csv("C:/joy_R/IDS_Finalexam/data/Countries.csv")
head(country_info)
recov_info <- read_csv("C:/joy_R/IDS_Finalexam/data/Recovered.csv")
head(recov_info)
```

```{r}
str(master_data)
```


```{r}
str(tests_info)
```


```{r}
str(country_info)
```

```{r}
str(recov_info)
```


### 2.Tidy up the dataframe driven from the file “Recovered.csv” to be compatible with the dataframe driven from the file “Covid19.csv”, i.e., every observation should have a record of recovered patients in one country in a single day.

```{r}
new_recov <- t(recov_info)
# head(new_recov)
```


```{r}
class(new_recov)
```

```{r}
new_recov2 <- as.data.frame(new_recov)
new_recov2
```


```{r}
colnames(new_recov2) <- c(new_recov2[1, ]) # assigning new column headers to each data frame in the list
new_recov2
new_recov3 <- new_recov2[-c(1), ]
new_recov3
new_recov3$date <- row.names(new_recov3)

new_recov3
```

```{r}
new_recov4 <- pivot_longer(new_recov3,
  cols = 1:185, names_to = "location",
  values_to = "cases"
)
new_recov4
```


```{r}
recov_5 <- new_recov4 %>%
  group_by(location) %>%
  arrange(location)
recov_5
```

```{r}
recov_6 <- recov_5 %>% select(location, everything())
recov_6
recov_6$date <- as.Date(recov_6$date, format = "%Y.%m.%d")
recov_6
```


### 3. Change the column names in the dataframes were loaded from the following files accordingly.
covid19.csv-Code,Country,Continent,Date,NewCases,NewDeaths
Tests.csv-Code, Date, NewTests
Countries.csv-Code,Country,Population,GDP,GDPCapita
Recovered.csv-Country,Date,Recovered

```{r}

colnames(master_data) <- c("Code", "Country", "Continent", "Date", "NewCases", "NewDeaths")
colnames(tests_info) <- c("Code", "Date", "NewTests")
colnames(country_info) <- c("Code", "Country", "Population", "GDP", "GDPCapita")
colnames(recov_6) <- c("Country", "Date", "Recovered")

head(master_data)
head(tests_info)
head(country_info)
head(recov_6)
```
### 4. Ensure that all dates variables are of date data type and with the same format across the dataframes.
```{r}
class(master_data$Date)
class(tests_info$Date)
class(recov_6$Date) # date variable changed to Date type in question-2 above.
# country_info data tibble doesnot have a Date variable. Rest in all data tibbles, the date variable is of Date type.
```

### 5. Considering the master dataframe is the one loaded from the “Covid19.csv” file, add new 5 variables to it from the other files (Recovered.csv, Tests.csv, Countries.csv). The 5 new added variables should be named (“Recovered”, “NewTests”, “Population”, “GDP”, “GDPCapita”) accordingly.

```{r}
# merging Recovered variable from the recov_6 dataframe. It has to be merged by using Date and Country column
m1 <- merge(x = master_data, y = recov_6, all.x = TRUE, by = c("Date", "Country"))
m1 <- m1 %>%
  group_by(Country) %>%
  arrange(Country)
m1
```

```{r}
# merging NewTests variable from the tests_info dataframe. It has to be merged by using Date and Code column
m2 <- merge(x = m1, y = tests_info, all.x = TRUE, by = c("Date", "Code"))
m2 <- m2 %>%
  group_by(Country) %>%
  arrange(Country)
m2
```

```{r}
# merging Population,GDP,GDPCapita variable from the country_info dataframe. It has to be merged by using Country and Code column
master_df <- merge(x = m2, y = country_info, all.x = TRUE, by = c("Code", "Country"))
master_df <- master_df %>%
  group_by(Country) %>%
  arrange(Country)
master_df
```

### 6.Check for NAs in all dataframes and change them to Zero
```{r}
# Check for NAs in master data frame
# is.na(master_df)
# converting Recovered column to numeric in master data frame
master_df$Recovered <- as.numeric(master_df$Recovered)
# changing NA values to 0
master_df[is.na(master_df)] <- 0
master_df # check the data frame
```


```{r}
# Check for NAs in tests_info tibble
tests_info %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather() %>%
  filter(value > 0)

# There are no NA values in tests_info
```
```{r}
# Check for NAs in country_info tibble
country_info %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather() %>%
  filter(value > 0)

# There are no NA values in country_info
```

```{r}
# Check for NAs in recov_6 data frame
recov_6 %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather() %>%
  filter(value > 0)

# there are 185 rows with an NA value

# changing NA values to 0
recov_6[is.na(recov_6)] <- 0
recov_6 # check the data frame
```

### 7. Using existing “Date” variable; add month and week variables to the master dataframe. [Hint: you may use functions from lubridate package]
```{r}
install.packages("lubridate")
library(lubridate)

master_df2 <- master_df %>% mutate(Month = month(Date))
master_df2
```

```{r}
master_df3 <- master_df2 %>% mutate(Week = week(Date))
master_df3
```

# ------------------------------------------------------------------------------------ #

## Task 2: Exploratory Data Analysis: (35 marks)

### 1. Add four new variables to the master dataframe (“CumCases”, “CumDeaths”, “CumRecovered”, “CumTests”). These variables should reflect the cumulative relevant data up to the date of the observation; i.e., CumCases for country “X” at Date “Y” should reflect the total number of cases in country “X” since the beginning of recording data till the date “Y”.

[Hint: first arrange by date and country, then for each new variable to be added you need to group by country and mutate the new column using the cumsum function]
```{r}
# cumulative sum function can be used here
# The master_df3 already has a date and country column which is arranged as per dates.
master_df4 <- master_df3 %>%
  group_by(Country) %>%
  mutate(CumCases = cumsum(NewCases), CumDeaths = cumsum(NewDeaths), CumRecovered = cumsum(Recovered), CumTests = cumsum(NewTests))
master_df4
```

### 2.Add two new variables to the master dataframe (“Active”, “FatalityRate”). Active variable should reflect the infected cases that has not been closed yet (by either recovery or death), and it could be calculated from (CumCases – (CumDeaths + CumRecovered)). On the other hand, FatalityRate variable should reflect the percentages of death to the infected cases up to date and it could be calculated from (CumDeaths / CumCases).
```{r}
master_df5 <- master_df4 %>% group_by(Country) %>% mutate(Active=cumsum(CumCases-(CumDeaths + CumRecovered)), FatalityRate=cumsum(CumDeaths / CumCases))
master_df5
```

### 3. Add four new variables to the master dataframe (“Cases_1M_Pop”, “Deaths_1M_Pop”, “Recovered_1M_Pop”, “Tests_1M_Pop”) These variables should reflect the cumulative relevant rate per one million of the corresponding country population, (i.e Cases_1M_Pop for country “X” at Date “Y” should reflect the total number of new cases up to date “Y” per million people of country “X” population)

[Hint: Cases_1M_Pop = CumCases*(10^6) / Population)]
```{r}
master_df6 <- master_df5 %>% group_by(Country) %>% mutate(Cases_1M_Pop=CumCases*(10^6) / Population, Deaths_1M_Pop=CumDeaths*(10^6) / Population, Recovered_1M_Pop=CumRecovered*(10^6) / Population, Tests_1M_Pop=CumTests*(10^6) / Population)
master_df6
```

### 4.Find the day with the highest reported death toll across the world. Print the date and the death toll of that day.
```{r}
deaths_per_day <- master_df6 %>% group_by(Date) %>% summarise(death_toll = sum(NewDeaths))


highest_death_toll <- deaths_per_day[[which.max(deaths_per_day$death_toll), "death_toll"]]
highest_death_toll
highest_death_date <- deaths_per_day[[which.max(deaths_per_day$death_toll), "Date"]]
highest_death_date

```

### 5.Build a graph to show how the cumulative data of (Infected Cases, Deaths, Recovered, Tests) change over the time for the whole world collectively.

[Hint: Use geom_line as a geometry function, use log for the Y axis for better presentation, Use different colour to distinguish between new cases, deaths, and recovered]

```{r}

#Using summarise function to take sum of daily cases of different countries on each date
master_df7 <- master_df6 %>% group_by(Date) %>% summarise(Cases_world=sum(NewCases), Deaths_world=sum(NewDeaths),Recovered_world=sum(Recovered), Tests_world=sum(NewTests))


#to get the cumulative data of the above world variables I use cumsum function
master_df7$Cases_world <- cumsum(master_df7$Cases_world)
master_df7$Deaths_world <- cumsum(master_df7$Deaths_world)
master_df7$Recovered_world <- cumsum(master_df7$Recovered_world)
master_df7$Tests_world <- cumsum(master_df7$Tests_world)

master_df7
```

```{r}
# taking log of each variable and plotting
library(ggplot2)
p <- ggplot(master_df7, aes(x = Date)) +
  geom_line(aes(y = Cases_world), colour = "green") +
  geom_line(aes(y = Deaths_world), colour = "red") +
  geom_line(aes(y = Recovered_world), colour = "blue") +
  geom_line(aes(y = Tests_world), colour = "grey") +
  xlab("Date") +
  ylab("Exponential values of cum cases, deaths,recovered, tests") +
  ggtitle("Trend of cumulative new cases, deaths,recovered and tests during Jan 2020 to May 2020 in the world")

# Possible values for trans : 'log2', 'log10'

# Format y axis tick mark labels to show exponents
require(scales)
p + scale_y_continuous(
  trans = log10_trans(),
  breaks = trans_breaks("log10", function(x) 10^x),
  labels = trans_format("log10", math_format(10^.x))
)



```


### 6.Extract the data corresonding to the last day (05/05/2020) and save it in a separate dataframe and name it “lastDay_data”.

[Hint: use filter function with Date = “2020-05-05”]

```{r}
lastDay_data <- master_df6 %>% filter(Date == "2020-05-05")
lastDay_data
```

### 7.Based on the data of the last day, extract the records of the top 10 countries worldwide that have current active cases, total confirmed cases, and fatality rate in separate dataframes (i.e., top10activeW, top10casesW, top10fatalityW, top10testsMW).

[Hint: you can use head(arranged_data, n=10) to get the top 10 records]



```{r}
top10activeW <- head(arrange(lastDay_data, desc(Active)), n=10)
top10activeW
```

```{r}
top10casesW <- head(arrange(lastDay_data, desc(CumCases)), n=10)
top10casesW
```

```{r}
top10fatalityW<-head(arrange(lastDay_data, desc(FatalityRate)), n=10)
top10fatalityW
```

```{r}

```

